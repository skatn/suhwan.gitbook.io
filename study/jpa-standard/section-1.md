# 섹션 1. JPA 소개

## SQL 중심적인 개발의 문제점

#### SQL에 의존적인 개발

* 객체 <-> SQL 변환을 위한 코드를 반복 작성해서 지루하다.
* 객체의 필드가 변경되면 관련된 모든 SQL을 수정 -> 실수가 생길 확률이 높다.

#### 객체와 관계형 데이터베이스의 패러다임 불일치

* 객체는 상속이라는 기능이 있지만 RDB에는 상속이 없다.
* 객체는 참조를 통해 연관관계를 맺고, 테이블은 외래키를 통해 연관관계를 맺는다.
* 객체는 객체 그래프를 통해 자유롭게 객체를 탐색할 수 있지만, SQL은 실행문에 따라 탐색 범위가 결정된다.
* SQL은 실행할 때 탐색 범위가 결정되기 때문에 객체 그래프를 신뢰할 수 없다.

객체와 관계형 데이터베이스의 패러다임이 다르기 때문에 객체를 정교하게 모델링 할수록 패러다임 불일치 문제가 커져 SQL로 변환하는데 비용이 너무 많이 들게 된다. 그래서 패러다임 불일치 문제를 해결하고 객체 모델링에 집중할 수 있도록 JPA라는 기술이 나오게 된다.

## JPA

#### JPA란?&#x20;

JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준이다.

{% hint style="info" %}
ORM이란?

* Object-relational mapping
* 객체와 관계형 데이터베이스를 매핑해서 패러다임 불일치 문제를 해결해준다.
{% endhint %}

#### JPA를 왜 사용해야 하는가?

* **생산성**\
  객체 <-> SQL 변환 작업을 JPA가 대신 처리해주기 때문에 CRUD를 자바 컬렉션 처럼 사용할 수 있다.
* **유지보수**\
  필드가 변경되면 관련된 모든 SQL을 수정해야 되는데, JPA를 사용하면 해당 작업을 대신 처리해주기 때문에 수정되는 코드의 양이 적다.
* **패러다임의 불일치 해결**
  * 상속: JPA가 알아서 부모, 자식 테이블로 분리하고 SQL을 처리해준다.
  * 연관관계: JPA가 객체 그래프를 보장해주기 때문에 참조된 엔티티를 신뢰할 수 있다.
* **성능 최적화**
  * 캐싱: 동일한 트랜잭션에서 처음 조회된 엔티티를 1차 캐시에 저장해두기 때문에 또 조회가 일어날 경우 메모리에서 바로 반환한다.
  * 쓰기 지연: 트랜잭션을 커밋할 때 까지 실행할 SQL을 모아두고, `JDBC BATCH SQL` 기능을 사용해서 한번에 전송한다.
* **지연 로딩**\
  객체를 조회할 때 조회 대상 객체만 로딩하고, 연관된 객체는 실제 사용되는 시점에 로딩된다.
* **즉시 로딩**\
  JOIN SQL로 한번에 연관된 객체까지 조회한다.
